//
// main.cpp
//
// http://www.codeproject.com/Articles/4610/Three-Ways-to-Inject-Your-Code-into-Another-Proces
//

#include <windows.h>
#include <stdio.h>
#include <Sddl.h>
#include <aclapi.h>
#include <Authz.h>
#include <VersionHelpers.h>

#include "../common.h"

#define LOGERROR wprintf
#define LOGINFO LOGERROR

class CInjectData {
private:
    bool FillShellcode(BOOL Is64bit, LPCWSTR DllPath, WORD Ordinal, PBYTE Buffer, DWORD Length) {
        if ( Length<sizeof(Package) ) {
            LOGERROR(L"Buffer is small\n", 0);
            return false;
        }

        Package *p = (Package*)Buffer;

        if ( !GetFullPathName(DllPath, MAX_PATH, (PWCHAR)p->DllPath, NULL) ) {
            LOGERROR(L"GetFullPathName failed - %08x\n", GetLastError());
            return false;
        }

        if ( Is64bit ) {
            static BYTE CODE64[] = {
                0x48, 0x89, 0x5c, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xec, 0x30, 0x65,
                0x48, 0x8b, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00, 0x48, 0x89, 0xcb, 0x31, 0xff, 0x48, 0x8b, 0x50,
                0x60, 0x48, 0x89, 0x91, 0x08, 0x0a, 0x00, 0x00, 0xe8, 0xae, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8b,
                0x10, 0x0a, 0x00, 0x00, 0x48, 0x89, 0xda, 0xe8, 0x33, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x8b, 0x00,
                0x08, 0x00, 0x00, 0xff, 0x93, 0x18, 0x0a, 0x00, 0x00, 0x48, 0x89, 0xc6, 0x48, 0x85, 0xc0, 0x74,
                0x23, 0xba, 0xad, 0xde, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xff, 0x93, 0x28, 0x0a, 0x00, 0x00, 0x48,
                0x85, 0xc0, 0x74, 0x07, 0x48, 0x89, 0xd9, 0xff, 0xd0, 0x89, 0xc7, 0x48, 0x89, 0xf1, 0xff, 0x93,
                0x20, 0x0a, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x20, 0x45, 0x78, 0x69, 0x74, 0xc7, 0x44, 0x24, 0x24,
                0x54, 0x68, 0x72, 0x65, 0x48, 0xc7, 0x44, 0x24, 0x28, 0x61, 0x64, 0x00, 0x00, 0x48, 0x8b, 0x8b,
                0x10, 0x0a, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x20, 0xff, 0x93, 0x28, 0x0a, 0x00, 0x00, 0x48,
                0x89, 0xc7, 0xc7, 0x44, 0x24, 0x28, 0x56, 0x69, 0x72, 0x74, 0xc7, 0x44, 0x24, 0x2c, 0x75, 0x61,
                0x6c, 0x46, 0xc7, 0x44, 0x24, 0x30, 0x72, 0x65, 0x65, 0x00, 0x48, 0x8b, 0x8b, 0x10, 0x0a, 0x00,
                0x00, 0x48, 0x8d, 0x54, 0x24, 0x28, 0xff, 0x93, 0x28, 0x0a, 0x00, 0x00, 0x31, 0xd2, 0x41, 0xb8,
                0x00, 0x80, 0x00, 0x00, 0x48, 0x89, 0xd9, 0x57, 0xff, 0xe0, 0xcc, 0x48, 0x8b, 0x81, 0x08, 0x0a,
                0x00, 0x00, 0x4c, 0x8b, 0x40, 0x18, 0x49, 0x8b, 0x50, 0x20, 0x49, 0x83, 0xc0, 0x20, 0x4c, 0x39,
                0xc2, 0x74, 0x7a, 0x4c, 0x8b, 0x89, 0x10, 0x0a, 0x00, 0x00, 0x90, 0x48, 0x8b, 0x42, 0x50, 0x4d,
                0x85, 0xc9, 0x75, 0x2a, 0x81, 0x38, 0x4b, 0x00, 0x45, 0x00, 0x75, 0x22, 0x81, 0x78, 0x04, 0x52,
                0x00, 0x4e, 0x00, 0x75, 0x19, 0x81, 0x78, 0x08, 0x45, 0x00, 0x4c, 0x00, 0x75, 0x10, 0x81, 0x78,
                0x0c, 0x33, 0x00, 0x32, 0x00, 0x75, 0x07, 0x66, 0x83, 0x78, 0x10, 0x2e, 0x74, 0x2a, 0x81, 0x38,
                0x6b, 0x00, 0x65, 0x00, 0x75, 0x2f, 0x81, 0x78, 0x04, 0x72, 0x00, 0x6e, 0x00, 0x75, 0x26, 0x81,
                0x78, 0x08, 0x65, 0x00, 0x6c, 0x00, 0x75, 0x1d, 0x81, 0x78, 0x0c, 0x33, 0x00, 0x32, 0x00, 0x75,
                0x14, 0x66, 0x83, 0x78, 0x10, 0x2e, 0x75, 0x0d, 0x4c, 0x8b, 0x4a, 0x20, 0x4c, 0x89, 0x89, 0x10,
                0x0a, 0x00, 0x00, 0xeb, 0x08, 0x48, 0x8b, 0x12, 0x4c, 0x39, 0xc2, 0x75, 0x8e, 0xc3, 0xcc, 0x48,
                0x83, 0xec, 0x08, 0xb8, 0x4d, 0x5a, 0x00, 0x00, 0x49, 0x89, 0xd2, 0x49, 0x89, 0xcb, 0x66, 0x39,
                0x01, 0x0f, 0x85, 0x5e, 0x01, 0x00, 0x00, 0x44, 0x8b, 0x49, 0x3c, 0x41, 0x81, 0x3c, 0x09, 0x50,
                0x45, 0x00, 0x00, 0x0f, 0x85, 0x4c, 0x01, 0x00, 0x00, 0x45, 0x0f, 0xb7, 0x44, 0x09, 0x04, 0xba,
                0x4c, 0x01, 0x00, 0x00, 0x66, 0x41, 0x39, 0xd0, 0x74, 0x0f, 0xb8, 0x64, 0x86, 0x00, 0x00, 0x66,
                0x41, 0x39, 0xc0, 0x0f, 0x85, 0x2c, 0x01, 0x00, 0x00, 0x48, 0x89, 0x6c, 0x24, 0x18, 0x66, 0x41,
                0x39, 0xd0, 0x48, 0x89, 0x74, 0x24, 0x20, 0x48, 0x89, 0x3c, 0x24, 0xb8, 0x70, 0x00, 0x00, 0x00,
                0xb9, 0x60, 0x00, 0x00, 0x00, 0x0f, 0x44, 0xc1, 0x45, 0x31, 0xc0, 0x4c, 0x01, 0xc8, 0x46, 0x8b,
                0x4c, 0x18, 0x18, 0x4d, 0x01, 0xd9, 0x41, 0x8b, 0x79, 0x20, 0x41, 0x8b, 0x71, 0x24, 0x41, 0x8b,
                0x69, 0x1c, 0x4c, 0x01, 0xdf, 0x4c, 0x01, 0xde, 0x4c, 0x01, 0xdd, 0x45, 0x39, 0x41, 0x18, 0x0f,
                0x86, 0xd2, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5c, 0x24, 0x10, 0x49, 0x8b, 0x9a, 0x18, 0x0a, 0x00,
                0x00, 0x0f, 0x1f, 0x00, 0x66, 0x0f, 0x1f, 0x04, 0x00, 0x42, 0x0f, 0xb7, 0x0c, 0x46, 0x42, 0x8b,
                0x04, 0x87, 0x8b, 0x54, 0x8d, 0x00, 0x4c, 0x01, 0xd8, 0x4c, 0x01, 0xda, 0x48, 0x85, 0xdb, 0x75,
                0x2b, 0x81, 0x38, 0x4c, 0x6f, 0x61, 0x64, 0x75, 0x23, 0x81, 0x78, 0x04, 0x4c, 0x69, 0x62, 0x72,
                0x75, 0x1a, 0x81, 0x78, 0x08, 0x61, 0x72, 0x79, 0x57, 0x75, 0x11, 0x38, 0x58, 0x0c, 0x75, 0x0c,
                0x48, 0x89, 0xd3, 0x49, 0x89, 0x92, 0x18, 0x0a, 0x00, 0x00, 0xeb, 0x69, 0x49, 0x83, 0xba, 0x20,
                0x0a, 0x00, 0x00, 0x00, 0x75, 0x23, 0x81, 0x38, 0x46, 0x72, 0x65, 0x65, 0x75, 0x1b, 0x81, 0x78,
                0x04, 0x4c, 0x69, 0x62, 0x72, 0x75, 0x12, 0x81, 0x78, 0x08, 0x61, 0x72, 0x79, 0x00, 0x75, 0x09,
                0x49, 0x89, 0x92, 0x20, 0x0a, 0x00, 0x00, 0xeb, 0x3c, 0x49, 0x83, 0xba, 0x28, 0x0a, 0x00, 0x00,
                0x00, 0x75, 0x32, 0x81, 0x38, 0x47, 0x65, 0x74, 0x50, 0x75, 0x2a, 0x81, 0x78, 0x04, 0x72, 0x6f,
                0x63, 0x41, 0x75, 0x21, 0x81, 0x78, 0x08, 0x64, 0x64, 0x72, 0x65, 0x75, 0x18, 0x8b, 0x48, 0x0c,
                0x81, 0xe1, 0xff, 0xff, 0xff, 0x00, 0x81, 0xf9, 0x73, 0x73, 0x00, 0x00, 0x75, 0x07, 0x49, 0x89,
                0x92, 0x28, 0x0a, 0x00, 0x00, 0x41, 0xff, 0xc0, 0x45, 0x3b, 0x41, 0x18, 0x0f, 0x82, 0x47, 0xff,
                0xff, 0xff, 0x48, 0x8b, 0x5c, 0x24, 0x10, 0x48, 0x8b, 0x74, 0x24, 0x20, 0x48, 0x8b, 0x6c, 0x24,
                0x18, 0x48, 0x8b, 0x3c, 0x24, 0x48, 0x83, 0xc4, 0x08, 0xc3, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
            };

            *(PDWORD)&(((PBYTE)CODE64)[0x52]) = (DWORD)Ordinal;
            CopyMemory(p->InitialCode, CODE64, sizeof(CODE64));
        }
        else {
            static BYTE CODE32[] = {
                0x83, 0xec, 0x10, 0x64, 0xa1, 0x30, 0x00, 0x00, 0x00, 0x53, 0x56, 0x8b, 0x74, 0x24, 0x1c, 0x57,
                0x56, 0xc7, 0x44, 0x24, 0x10, 0x23, 0x01, 0x00, 0x00, 0x31, 0xff, 0xc7, 0x44, 0x24, 0x14, 0x00,
                0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x18, 0x56, 0x04, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x1c, 0x00,
                0x00, 0x00, 0x00, 0x89, 0x86, 0x08, 0x0a, 0x00, 0x00, 0xe8, 0xa0, 0x00, 0x00, 0x00, 0x56, 0xff,
                0xb6, 0x0c, 0x0a, 0x00, 0x00, 0xe8, 0x23, 0x01, 0x00, 0x00, 0x83, 0xc4, 0x0c, 0x8d, 0x86, 0x00,
                0x08, 0x00, 0x00, 0x50, 0x8b, 0x86, 0x10, 0x0a, 0x00, 0x00, 0xff, 0xd0, 0x89, 0xc3, 0x85, 0xdb,
                0x74, 0x20, 0x8b, 0x86, 0x18, 0x0a, 0x00, 0x00, 0x68, 0xad, 0xde, 0x00, 0x00, 0x53, 0xff, 0xd0,
                0x85, 0xc0, 0x74, 0x05, 0x56, 0xff, 0xd0, 0x89, 0xc7, 0x8b, 0x8e, 0x14, 0x0a, 0x00, 0x00, 0x53,
                0xff, 0xd1, 0x8d, 0x44, 0x24, 0x0c, 0xc7, 0x00, 0x45, 0x78, 0x69, 0x74, 0xc7, 0x40, 0x04, 0x54,
                0x68, 0x72, 0x65, 0xc7, 0x40, 0x08, 0x61, 0x64, 0x00, 0x00, 0x50, 0xff, 0xb6, 0x0c, 0x0a, 0x00,
                0x00, 0x8b, 0x86, 0x18, 0x0a, 0x00, 0x00, 0xff, 0xd0, 0x89, 0xc7, 0x8d, 0x44, 0x24, 0x0c, 0xc7,
                0x00, 0x56, 0x69, 0x72, 0x74, 0xc7, 0x40, 0x04, 0x75, 0x61, 0x6c, 0x46, 0xc7, 0x40, 0x08, 0x72,
                0x65, 0x65, 0x00, 0x50, 0xff, 0xb6, 0x0c, 0x0a, 0x00, 0x00, 0x8b, 0x86, 0x18, 0x0a, 0x00, 0x00,
                0xff, 0xd0, 0x68, 0x00, 0x80, 0x00, 0x00, 0x6a, 0x00, 0x56, 0x57, 0xff, 0xe0, 0xcc, 0x53, 0x8b,
                0x5c, 0x24, 0x08, 0x57, 0x8b, 0x83, 0x08, 0x0a, 0x00, 0x00, 0x8b, 0x78, 0x0c, 0x83, 0xc7, 0x14,
                0x8b, 0x17, 0x39, 0xfa, 0x74, 0x73, 0x56, 0x8b, 0xb3, 0x0c, 0x0a, 0x00, 0x00, 0x90, 0x8b, 0x42,
                0x28, 0x85, 0xf6, 0x75, 0x2a, 0x81, 0x38, 0x4b, 0x00, 0x45, 0x00, 0x75, 0x22, 0x81, 0x78, 0x04,
                0x52, 0x00, 0x4e, 0x00, 0x75, 0x19, 0x81, 0x78, 0x08, 0x45, 0x00, 0x4c, 0x00, 0x75, 0x10, 0x81,
                0x78, 0x0c, 0x33, 0x00, 0x32, 0x00, 0x75, 0x07, 0x66, 0x83, 0x78, 0x10, 0x2e, 0x74, 0x2a, 0x81,
                0x38, 0x6b, 0x00, 0x65, 0x00, 0x75, 0x2b, 0x81, 0x78, 0x04, 0x72, 0x00, 0x6e, 0x00, 0x75, 0x22,
                0x81, 0x78, 0x08, 0x65, 0x00, 0x6c, 0x00, 0x75, 0x19, 0x81, 0x78, 0x0c, 0x33, 0x00, 0x32, 0x00,
                0x75, 0x10, 0x66, 0x83, 0x78, 0x10, 0x2e, 0x75, 0x09, 0x8b, 0x72, 0x10, 0x89, 0xb3, 0x0c, 0x0a,
                0x00, 0x00, 0x8b, 0x12, 0x39, 0xfa, 0x75, 0x96, 0x5e, 0x5f, 0x5b, 0xc3, 0xcc, 0x83, 0xec, 0x08,
                0xb8, 0x4d, 0x5a, 0x00, 0x00, 0x57, 0x8b, 0x7c, 0x24, 0x10, 0x66, 0x39, 0x07, 0x0f, 0x85, 0x36,
                0x01, 0x00, 0x00, 0x8b, 0x57, 0x3c, 0x81, 0x3c, 0x3a, 0x50, 0x45, 0x00, 0x00, 0x0f, 0x85, 0x26,
                0x01, 0x00, 0x00, 0x0f, 0xb7, 0x4c, 0x3a, 0x04, 0x53, 0xbb, 0x4c, 0x01, 0x00, 0x00, 0x66, 0x39,
                0xd9, 0x74, 0x0e, 0xb8, 0x64, 0x86, 0x00, 0x00, 0x66, 0x39, 0xc1, 0x0f, 0x85, 0x07, 0x01, 0x00,
                0x00, 0x55, 0x66, 0x39, 0xd9, 0xb8, 0x70, 0x00, 0x00, 0x00, 0x56, 0xbe, 0x60, 0x00, 0x00, 0x00,
                0x0f, 0x44, 0xc6, 0x31, 0xf6, 0x01, 0xd0, 0x8b, 0x6c, 0x38, 0x18, 0x8b, 0x44, 0x3d, 0x20, 0x01,
                0xfd, 0x01, 0xf8, 0x89, 0x44, 0x24, 0x10, 0x8b, 0x4d, 0x24, 0x8b, 0x55, 0x1c, 0x01, 0xf9, 0x01,
                0xfa, 0x89, 0x4c, 0x24, 0x14, 0x89, 0x54, 0x24, 0x1c, 0x39, 0x75, 0x18, 0x0f, 0x86, 0xc4, 0x00,
                0x00, 0x00, 0x8b, 0x54, 0x24, 0x20, 0x8b, 0x9a, 0x10, 0x0a, 0x00, 0x00, 0x90, 0x0f, 0xb7, 0x0c,
                0x71, 0x8b, 0x54, 0x24, 0x1c, 0x8b, 0x04, 0xb0, 0x01, 0xf8, 0x8b, 0x0c, 0x8a, 0x8b, 0x54, 0x24,
                0x20, 0x01, 0xf9, 0x85, 0xdb, 0x75, 0x2a, 0x81, 0x38, 0x4c, 0x6f, 0x61, 0x64, 0x75, 0x22, 0x81,
                0x78, 0x04, 0x4c, 0x69, 0x62, 0x72, 0x75, 0x19, 0x81, 0x78, 0x08, 0x61, 0x72, 0x79, 0x57, 0x75,
                0x10, 0x80, 0x78, 0x0c, 0x00, 0x75, 0x0a, 0x89, 0xcb, 0x89, 0x8a, 0x10, 0x0a, 0x00, 0x00, 0xeb,
                0x63, 0x83, 0xba, 0x14, 0x0a, 0x00, 0x00, 0x00, 0x75, 0x22, 0x81, 0x38, 0x46, 0x72, 0x65, 0x65,
                0x75, 0x1a, 0x81, 0x78, 0x04, 0x4c, 0x69, 0x62, 0x72, 0x75, 0x11, 0x81, 0x78, 0x08, 0x61, 0x72,
                0x79, 0x00, 0x75, 0x08, 0x89, 0x8a, 0x14, 0x0a, 0x00, 0x00, 0xeb, 0x38, 0x83, 0xba, 0x18, 0x0a,
                0x00, 0x00, 0x00, 0x75, 0x2f, 0x81, 0x38, 0x47, 0x65, 0x74, 0x50, 0x75, 0x27, 0x81, 0x78, 0x04,
                0x72, 0x6f, 0x63, 0x41, 0x75, 0x1e, 0x81, 0x78, 0x08, 0x64, 0x64, 0x72, 0x65, 0x75, 0x15, 0x8b,
                0x40, 0x0c, 0x25, 0xff, 0xff, 0xff, 0x00, 0x3d, 0x73, 0x73, 0x00, 0x00, 0x75, 0x06, 0x89, 0x8a,
                0x18, 0x0a, 0x00, 0x00, 0x8b, 0x44, 0x24, 0x10, 0x46, 0x8b, 0x4c, 0x24, 0x14, 0x3b, 0x75, 0x18,
                0x0f, 0x82, 0x47, 0xff, 0xff, 0xff, 0x5e, 0x5d, 0x5b, 0x5f, 0x83, 0xc4, 0x08, 0xc3, 0xcc, 0x00,
            };

            *(PDWORD)&(((PBYTE)CODE32)[0x69]) = (DWORD)Ordinal;
            CopyMemory(p->InitialCode, CODE32, sizeof(CODE32));
        }

        return true;
    }

    //
    // https://msdn.microsoft.com/en-us/library/windows/desktop/aa379283(v=vs.85).aspx
    //
    // DACL for "C:\Program Files" contains "(A;;0x1200a9;;;AC)(A;OICIIO;GXGR;;;AC)"
    // Ace[0]
    //     AceType:       0x00 (ACCESS_ALLOWED_ACE_TYPE)
    //     AceFlags:      0x00
    //     AceSize:       0x0018
    //     Access Mask:   0x001200a9
    //                         READ_CONTROL
    //                         SYNCHRONIZE
    //                         Others(0x000000a9)
    //     Ace Sid:       S-1-15-2-1
    // Ace[1]
    //     AceType:       0x00 (ACCESS_ALLOWED_ACE_TYPE)
    //     AceFlags:      0x0b
    //                        OBJECT_INHERIT_ACE
    //                        CONTAINER_INHERIT_ACE
    //                        INHERIT_ONLY_ACE
    //     AceSize:       0x0018
    //     Access Mask:   0xa0000000
    //                         GENERIC_EXECUTE
    //                         GENERIC_READ
    //     Ace Sid:       S-1-15-2-1
    //
    // Account: ALL APPLICATION PACKAGES
    // Domain:  APPLICATION PACKAGE AUTHORITY
    // SID:     S-1-15-2-1
    // Type:    SidTypeWellKnownGroup
    //
    bool AddPermissionForAppContainer(LPCWSTR Filename) {
        bool Ret = false;
        DWORD Status = ERROR_SUCCESS;
        PACL OldDacl = NULL;
        PACL NewDacl = NULL;
        PSECURITY_DESCRIPTOR Sd = NULL;
        EXPLICIT_ACCESS NewAce;
        PSID AppContainerSid = NULL;

        // SetNamedSecurityInfo requires non-const string.
        WCHAR FileNameCopy[MAX_PATH];
        if ( !GetFullPathName(Filename, MAX_PATH, FileNameCopy, NULL) ) {
            LOGERROR(L"GetFullPathName failed - %08x\n", Status);
            goto cleanup;
        }

        Status = GetNamedSecurityInfo(FileNameCopy, SE_FILE_OBJECT,
            DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION, // AuthzAccessCheck requires Owner
            NULL, NULL, &OldDacl, NULL, &Sd);
        if ( Status!=ERROR_SUCCESS ) {
            LOGERROR(L"GetNamedSecurityInfo failed - %08x\n", Status);
            goto cleanup;
        }

        if ( !ConvertStringSidToSid(L"AC", &AppContainerSid) ) {
            LOGERROR(L"ConvertStringSidToSid failed - %08x\n", GetLastError());
            goto cleanup;
        }

        if ( GetAccessRights(AppContainerSid, Sd)!=ERROR_SUCCESS ) {
            LOGERROR(L"AppContainer process does not have permission to load the file. Adding an ACE..\n", 0);

            ZeroMemory(&NewAce, sizeof(NewAce));
            NewAce.grfAccessPermissions = GENERIC_READ|GENERIC_EXECUTE;
            NewAce.grfAccessMode = GRANT_ACCESS;
            NewAce.grfInheritance = NO_INHERITANCE;
            NewAce.Trustee.pMultipleTrustee = NULL;
            NewAce.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            NewAce.Trustee.TrusteeForm = TRUSTEE_IS_SID;
            NewAce.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            NewAce.Trustee.ptstrName = (LPWSTR)AppContainerSid;

            Status = SetEntriesInAcl(1, &NewAce, OldDacl, &NewDacl);
            if ( Status!=ERROR_SUCCESS ) {
                LOGERROR(L"SetEntriesInAcl failed - %08x\n", Status);
                goto cleanup;
            }

            Status = SetNamedSecurityInfo(FileNameCopy, SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION, NULL, NULL, NewDacl, NULL);
            if ( Status!=ERROR_SUCCESS ) {
                LOGERROR(L"SetNamedSecurityInfo failed - %08x\n", Status);
                goto cleanup;
            }
        }

        Ret = true;

    cleanup:
        if ( NewDacl ) LocalFree(NewDacl);
        if ( AppContainerSid ) LocalFree(AppContainerSid);
        if ( Sd ) LocalFree(Sd);

        return Ret;
    }

    //
    // https://msdn.microsoft.com/en-us/library/windows/desktop/aa446637(v=vs.85).aspx
    //
    DWORD GetAccessRights(PSID Sid, PSECURITY_DESCRIPTOR Sd) {
        AUTHZ_RESOURCE_MANAGER_HANDLE ResourceManager = NULL;
        LUID UnusedId = {0, 0};
        AUTHZ_CLIENT_CONTEXT_HANDLE ClientContext = NULL;
        AUTHZ_ACCESS_REQUEST AccessRequest;
        AUTHZ_ACCESS_REPLY AccessReply;
        ACCESS_MASK GrantedAccessMask = 0;
        DWORD AccessCheckError = 0;

        if ( !AuthzInitializeResourceManager(AUTHZ_RM_FLAG_NO_AUDIT, NULL, NULL, NULL, NULL, &ResourceManager) ) {
            LOGERROR(L"AuthzInitializeRemoteResourceManager failed - %08x\n", GetLastError());
            goto cleanup;
        }

        if ( !AuthzInitializeContextFromSid(0, Sid, ResourceManager, NULL, UnusedId, NULL, &ClientContext) ) {
            LOGERROR(L"AuthzInitializeContextFromSid failed - %08x\n", GetLastError());
            goto cleanup;
        }

        ZeroMemory(&AccessRequest, sizeof(AccessRequest));
        AccessRequest.DesiredAccess = MAXIMUM_ALLOWED;
        AccessRequest.PrincipalSelfSid = NULL;
        AccessRequest.ObjectTypeList = NULL;
        AccessRequest.ObjectTypeListLength = 0;
        AccessRequest.OptionalArguments = NULL;

        ZeroMemory(&AccessReply, sizeof(AccessReply));
        AccessReply.ResultListLength = 1;
        AccessReply.GrantedAccessMask = &GrantedAccessMask;
        AccessReply.Error = &AccessCheckError;

        if ( !AuthzAccessCheck(0, ClientContext, &AccessRequest, NULL, Sd, NULL, 0, &AccessReply, NULL) ) {
            LOGERROR(L"AuthzAccessCheck failed - %08x\n", GetLastError());
            goto cleanup;
        }

    cleanup:
        if ( ClientContext ) AuthzFreeContext(ClientContext);
        if ( ResourceManager ) AuthzFreeResourceManager(ResourceManager);

        return AccessCheckError;
    }

public:
    CInjectData() {}

    bool FillData(BOOL Is64bit, LPCWSTR FilePath, INT Ordinal, PBYTE Buffer, DWORD Length) {
        bool Ret = false;
        if ( Ordinal>=0 && Ordinal<=0xFFFF ) {
            if ( !IsWindows8OrGreater() || AddPermissionForAppContainer(FilePath) ) {
                Ret = FillShellcode(Is64bit, FilePath, (WORD)Ordinal, Buffer, Length);
            }
        }
        else {
            HANDLE FileHandle = CreateFile(FilePath,
                GENERIC_READ, FILE_SHARE_READ,
                NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if ( FileHandle==INVALID_HANDLE_VALUE ) {
                LOGERROR(L"CreateFile failed - %08x\n", GetLastError());
            }
            else {
                DWORD BytesWritten = 0;
                if ( ReadFile(FileHandle, Buffer, Length, &BytesWritten, NULL) ) {
                    Ret = true;
                }
                else {
                    LOGERROR(L"ReadFile failed - %08x\n", GetLastError());
                }
                CloseHandle(FileHandle);
            }
        }
        return Ret;
    }
};

void Inject(DWORD RemoteProcessId, LPCWSTR FilenameToInject, INT Ordinal, bool Wait) {

    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx
    CONST DWORD DesiredAccess =
        PROCESS_VM_OPERATION |      // VirtualAllocEx
        PROCESS_QUERY_INFORMATION | // IsWow64Process
        PROCESS_VM_WRITE |          // WriteProcessMemory
        PROCESS_CREATE_THREAD;      // CreateThread

    CONST DWORD PackageSize = 4096; // 4K should be enough

    HANDLE TargetProcess = NULL;
    PVOID RemoteAddress = NULL;
    BYTE InjectionPackage[PackageSize];
    SIZE_T BytesWritten = 0;
    HANDLE RemoteThread = NULL;
    DWORD RemoteThreadId = 0;
    DWORD WaitResult = 0;

    CInjectData inject;

    SYSTEM_INFO si;
    enum PLATFORM {win32, win64, wow64} Platform = win32;
    CONST WCHAR PLATFORM_LABEL[][10] = { L"WIN32", L"WIN64", L"WOW64" };

    TargetProcess = OpenProcess(DesiredAccess, FALSE, RemoteProcessId);
    if ( !TargetProcess ) {
        LOGERROR(L"OpenProcess failed - %08x\n", GetLastError());
        goto cleanup;
    }

    ZeroMemory(&si, sizeof(si));
    GetNativeSystemInfo(&si);
    if ( si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64 ) {
        BOOL IsWow64 = FALSE;
        if ( !IsWow64Process(TargetProcess, &IsWow64) ) {
            LOGERROR(L"IsWow64Process failed - %08x\n", GetLastError());
            goto cleanup;
        }
        Platform = IsWow64 ? wow64 : win64;
    }
    else if ( si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_INTEL ) {
        Platform = win32;
    }
    else {
        LOGERROR(L"Unsupported platform.\n", 0);
        goto cleanup;
    }

    ZeroMemory(&InjectionPackage, sizeof(InjectionPackage));
    if ( !inject.FillData(
            Platform==win64,
            FilenameToInject,
            Ordinal,
            InjectionPackage,
            PackageSize) ) {
        goto cleanup;
    }

    RemoteAddress = VirtualAllocEx(TargetProcess, NULL, PackageSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if ( !RemoteAddress ) {
        LOGERROR(L"VirtualAllocEx failed - %08x\n", GetLastError());
        goto cleanup;
    }

    if ( !WriteProcessMemory(TargetProcess, RemoteAddress, InjectionPackage, PackageSize, &BytesWritten) ) {
        LOGERROR(L"WriteProcessMemory failed - %08x\n", GetLastError());
        goto cleanup;
    }

    RemoteThread = CreateRemoteThread(TargetProcess, NULL, 0,
        (LPTHREAD_START_ROUTINE)RemoteAddress, RemoteAddress,
        0, &RemoteThreadId);
    if ( !RemoteThread ) {
        LOGERROR(L"CreateRemoteThread failed - %08x\n", GetLastError());
        goto cleanup;
    }

    LOGINFO(L"Hijacking: PID=%04x (%s) TID=%04x VM=%p\n",
        RemoteProcessId, PLATFORM_LABEL[Platform], RemoteThreadId, RemoteAddress);

    if ( Wait ) {
        WaitResult = WaitForSingleObject(RemoteThread, INFINITE);
        if ( WaitResult!=WAIT_OBJECT_0 ) {
            LOGERROR(L"WaitForSingleObject failed - %08x\n", WaitResult);
            goto cleanup;
        }
    }

cleanup:
    if ( RemoteThread ) CloseHandle(RemoteThread);
    if ( RemoteAddress && Wait ) {
        // VirtualFreeEx won't cause double-free if the page is freed by the injected code.
        // https://msdn.microsoft.com/en-us/library/windows/desktop/aa366892(v=vs.85).aspx
        VirtualFreeEx(TargetProcess, RemoteAddress, 0, MEM_RELEASE);
    }
    if ( TargetProcess ) CloseHandle(TargetProcess);
}

int wmain(int argc, WCHAR *argv[]) {
    if ( argc<3 ) {
        LOGINFO(L"usage: pj [-w] <pid> <file> [ordinal#]\n");
    }
    else if (_wcsicmp(argv[1], L"-W")==0 ) {
        Inject(_wtoi(argv[2]), argv[3], argc>=5 ? _wtoi(argv[4]) : -1, true);
    }
    else {
        Inject(_wtoi(argv[1]), argv[2], argc>=4 ? _wtoi(argv[3]) : -1, false);
    }

    return 0;
}
