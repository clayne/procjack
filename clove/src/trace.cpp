#include <windows.h>
#include <vector>
#include <memory>
#include <intrin.h>
#include "../../common.h"
#include "event.h"
#include "pack.h"
#include "page.h"

void Log(LPCWSTR format, ...);
uint64_t hex_to_uint64(const char *s);
void WaitAndThenCleanup();

extern ExecutablePages g_exec_pages;
extern std::vector<std::unique_ptr<CodePack>> g_packs;
extern SRWLOCK g_shim_lock;

struct FunctionTracePack final : public CodePack {
  __declspec(noinline)
  void Push(uint64_t ticks,
            void **stack,
            void *arg1,
            void *arg2,
            void *arg3,
            void*,
            void*,
            void*,
            void*,
            void*) {
#if 0
    Log(L"[%d] %llu: %S %p %p %p %p...\n",
        call_count_,
        ticks,
        __FUNCTION__,
        stack,
        arg1,
        arg2,
        arg3);
#endif
    InterlockedIncrement(&call_count_);
    AcquireSRWLockExclusive(&record_lock_);
    if (records_.size() < max_records_)
      records_.emplace_back(ticks, *stack, arg1, arg2, arg3);
    ReleaseSRWLockExclusive(&record_lock_);
  }

  class FunctionTraceTemplate : public CodeTemplate {
#ifdef _WIN64
    static constexpr uint8_t blob[] = {
      0x48, 0x81, 0xec, 0x20, 0x00, 0x00, 0x00, 0x48,
      0x89, 0x5c, 0x24, 0x18, 0x48, 0x89, 0x54, 0x24,
      0x10, 0x48, 0x89, 0x4c, 0x24, 0x08, 0x55, 0x56,
      0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41,
      0x57, 0x48, 0x81, 0xec, 0x60, 0x00, 0x00, 0x00,
      0x4d, 0x89, 0xcc, 0x4d, 0x89, 0xc5, 0x49, 0x89,
      0xd2, 0x49, 0x89, 0xcb, 0x0f, 0x01, 0xf9, 0x48,
      0xc1, 0xe2, 0x20, 0x48, 0x09, 0xd0, 0x49, 0x89,
      0xc6, 0x4c, 0x8b, 0xbc, 0x24, 0xd8, 0x00, 0x00, // 40
      0x00, 0x48, 0x8b, 0xac, 0x24, 0xd0, 0x00, 0x00,
      0x00, 0x48, 0x8b, 0xbc, 0x24, 0xc8, 0x00, 0x00,
      0x00, 0x48, 0x8b, 0x9c, 0x24, 0xc0, 0x00, 0x00,
      0x00, 0x4c, 0x89, 0x7c, 0x24, 0x38, 0x48, 0x89,
      0x6c, 0x24, 0x30, 0x48, 0x89, 0x7c, 0x24, 0x28,
      0x48, 0x89, 0x5c, 0x24, 0x20, 0x4d, 0x89, 0xe8,
      0x4c, 0x89, 0xd2, 0x4c, 0x89, 0xd9, 0x48, 0xb8,
      0x11, 0x22, 0x33, 0x44, 0xaa, 0xcc, 0xbb, 0xdd, // 80
      0xff, 0xd0, 0x48, 0x89, 0xc6, 0x0f, 0x01, 0xf9,
      0x48, 0xc1, 0xe2, 0x20, 0x48, 0x09, 0xc2, 0x4c,
      0x29, 0xf2, 0x4c, 0x89, 0x7c, 0x24, 0x50, 0x48,
      0x89, 0x6c, 0x24, 0x48, 0x48, 0x89, 0x7c, 0x24,
      0x40, 0x48, 0x89, 0x5c, 0x24, 0x38, 0x4c, 0x89,
      0x64, 0x24, 0x30, 0x4c, 0x89, 0x6c, 0x24, 0x28,
      0x48, 0x89, 0x4c, 0x24, 0x20, 0x4c, 0x8b, 0x8c,
      0x24, 0xa0, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x84, // C0
      0x24, 0xb8, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8c,
      0x24, 0xa8, 0x00, 0x00, 0x00, 0x48, 0xb9, 0x44,
      0x33, 0x22, 0x11, 0xdd, 0xcc, 0xbb, 0xaa, 0x48,
      0xb8, 0x88, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x00, 0xff, 0xd0, 0x48, 0x8b, 0x9c, 0x24, 0xb0,
      0x00, 0x00, 0x00, 0x48, 0x89, 0xf0, 0x48, 0x81,
      0xc4, 0x60, 0x00, 0x00, 0x00, 0x41, 0x5f, 0x41,
      0x5e, 0x41, 0x5d, 0x41, 0x5c, 0x5f, 0x5e, 0x5d, // 100
      0x48, 0x81, 0xc4, 0x20, 0x00, 0x00, 0x00, 0xc3,
    };
    static constexpr uint32_t offset_Trampoline = 0x80;
    static constexpr uint32_t offset_FunctionTracePack = 0xd7;
    static constexpr uint32_t offset_FunctionTracePackPush = 0xe1;
#else
    static constexpr uint8_t blob[] = {
      0x81, 0xec, 0x14, 0x00, 0x00, 0x00, 0x56, 0x89,
      0x4c, 0x24, 0x10, 0x89, 0x54, 0x24, 0x14, 0x0f,
      0x01, 0xf9, 0x89, 0x44, 0x24, 0x04, 0x89, 0x54,
      0x24, 0x08, 0xff, 0x74, 0x24, 0x38, 0xff, 0x74,
      0x24, 0x38, 0xff, 0x74, 0x24, 0x38, 0xff, 0x74,
      0x24, 0x38, 0xff, 0x74, 0x24, 0x38, 0xff, 0x74,
      0x24, 0x38, 0xff, 0x74, 0x24, 0x38, 0xff, 0x74,
      0x24, 0x38, 0x8b, 0x4c, 0x24, 0x30, 0x8b, 0x54,
      0x24, 0x34, 0xb8, 0x11, 0x22, 0x33, 0x44, 0xff, // 40
      0xd0, 0x81, 0xc4, 0x20, 0x00, 0x00, 0x00, 0x89,
      0x44, 0x24, 0x0c, 0x0f, 0x01, 0xf9, 0xff, 0x74,
      0x24, 0x38, 0xff, 0x74, 0x24, 0x38, 0xff, 0x74,
      0x24, 0x38, 0xff, 0x74, 0x24, 0x38, 0xff, 0x74,
      0x24, 0x38, 0xff, 0x74, 0x24, 0x38, 0xff, 0x74,
      0x24, 0x38, 0xff, 0x74, 0x24, 0x38, 0x8d, 0x4c,
      0x24, 0x30, 0xff, 0x31, 0x81, 0xc1, 0x08, 0x00,
      0x00, 0x00, 0x51, 0x2b, 0x44, 0x24, 0x2c, 0x1b, // 80
      0x54, 0x24, 0x30, 0x52, 0x50, 0xb9, 0x44, 0x33,
      0x22, 0x11, 0xb8, 0x88, 0x77, 0x66, 0x55, 0xff,
      0xd0, 0x81, 0xc4, 0x04, 0x00, 0x00, 0x00, 0x8b,
      0x44, 0x24, 0x0c, 0x5e, 0x81, 0xc4, 0x14, 0x00,
      0x00, 0x00, 0xc3,
    };
    static constexpr uint32_t offset_Trampoline = 0x43;
    static constexpr uint32_t offset_FunctionTracePack = 0x8e;
    static constexpr uint32_t offset_FunctionTracePackPush = 0x93;
#endif

  public:
    size_t Size() const {
      return sizeof(blob);
    }

    void CopyTo(void *destination) const {
      std::memcpy(destination, blob, sizeof(blob));
    }

    bool Fill(void *start_address,
              const FunctionTracePack *pack,
              decltype(&FunctionTracePack::Push) func_to_push,
              const void *trampoline) const {
      *at<const void*>(start_address, offset_Trampoline) = trampoline;
      *at<const void*>(start_address, offset_FunctionTracePack) = pack;
      *at<decltype(func_to_push)>(start_address, offset_FunctionTracePackPush)
        = func_to_push;
      return true;
    }
  };

  struct Record {
    const uint32_t tid_;
    const uint64_t ticks_;
    const void *ret_;
    const void *args_[3];
    Record(uint64_t ticks,
           void *ret,
           void *arg1,
           void *arg2,
           void *arg3)
      : tid_(GetCurrentThreadId()),
        ticks_(ticks),
        ret_(ret),
        args_{arg1, arg2, arg3}
    {}
  };

  const FunctionTraceTemplate function_template_;
  static constexpr uint32_t max_records_ = 1000000;
  std::vector<Record> records_;
  SRWLOCK record_lock_;
  uint32_t call_count_;
  const void *function_target_;
  void *function_trampoline_;
  void *function_detour_;

  FunctionTracePack(void *target)
    : record_lock_(SRWLOCK_INIT),
      call_count_(0),
      function_target_(target),
      function_trampoline_(target),
      function_detour_(nullptr) {
    records_.reserve(max_records_);
  }

  bool ActivateDetourInternal(ExecutablePages &exec_pages) {
    function_detour_ = exec_pages.Push(function_template_,
                                       function_target_);
    bool ret = DetourAttachHelper(function_trampoline_, function_detour_);
    if (ret) {
      ret = function_template_.Fill(
        function_detour_,
        this,
        &FunctionTracePack::Push,
        function_trampoline_);
    }
    if (!ret && function_detour_) {
      exec_pages.Revert(function_detour_);
    }
    return ret;
  }

  bool DeactivateDetourInternal(ExecutablePages&) {
    return DetourDetachHelper(function_trampoline_, function_detour_);
  }

  void Print() const {
    Log(L"[FunctionTracePack %p] %d calls (%zd records stored at %p %p-1)\n",
        function_target_,
        call_count_,
        records_.size(),
        records_.begin(),
        records_.end());
  }
};
/*
void *FunctionTracePack_Start(void *arg1,
                              void *arg2,
                              void *arg3,
                              void *arg4,
                              void *arg5,
                              void *arg6,
                              void *arg7,
                              void *arg8) {
  auto instance = reinterpret_cast<FunctionTracePack*>(0xaabbccdd11223344);
  auto trampoline = reinterpret_cast<decltype(&FunctionTracePack_Start)>(0xddbbccaa44332211);
  auto rsp = reinterpret_cast<void**>(0x8877665544332211);
  uint64_t t = __rdtscp(0);
  auto ret = trampoline(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
  instance->Push(__rdtscp(0) - t,
                 rsp,
                 arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
  return ret;
}
*/
void FunctionTrace(Package *package) {
  auto target = hex_to_uint64(package->args);
  if (!target) {
    Log(L"Invalid address!\n");
    return;
  }
  if (auto new_pack = std::make_unique<FunctionTracePack>(
        reinterpret_cast<void*>(target))) {
    AcquireSRWLockExclusive(&g_shim_lock);
    if (new_pack->ActivateDetour(g_exec_pages)) {
      g_packs.emplace_back(std::move(new_pack));
    }
    ReleaseSRWLockExclusive(&g_shim_lock);
  }
  WaitAndThenCleanup();
}
